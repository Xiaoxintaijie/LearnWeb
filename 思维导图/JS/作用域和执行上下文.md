## 执行上下文
执行上下文就是当前JavaScript代码被解析和执行时所在的**环境**
JavaScript中运行任何的代码都是在执行上下文中运行

#### 执行上下文类型
- 全局执行上下文
  1. 默认/基础的上下文,任何不在函数内部的代码都在全局上下文中
  2. 一个程序中只会有一个全局执行上下文
- 函数执行上下文
  1. 每当一个函数被调用时,都会为该函数创建一个新的执行上下文
  2. 函数上下文可以有任意多个
- eval函数执行上下文
  不常用,不做讨论

#### 生命周期
##### 1.创建阶段
- this指向绑定
  1. 全局执行上下文中,this指向全局对象/window
  2. 函数执行上下文中,this取决于函数被调用的形式
  详情见标题

- 创建**词法环境**
  词法环境由以下两部分组成
  - 全局环境(没有外部环境的词法环境)
  - 函数环境(外部环境的引用)
  存储函数声明和变量let和const绑定

- 创建**变量环境**
  用于存储变量var绑定

##### 2.执行阶段
- 执行栈
  1. 用来存储代码运行时创建的所有执行上下文
  2. 先进后出的结构
  3. **事件循环**

##### 3.回收阶段
- **垃圾回收机制**

## 作用域
#### 变量
- 全局变量
  1. 全局作用域下声明的变量
  2. 在全局作用域的任何一地方，都可以访问这个变量
  3. 只有浏览器关闭时才会被销毁,比较占内存
- 局部变量
  1. 定义在函数作用域的变量
  2. 仅限函数内部访问这个变量
  3. 当其所在的代码块运行结束后,就会被销毁,比较节约内存

- 变量如果未经声明就赋值,视为全局变量
- 当局部变量和全局变量重名,则在函数内部,变量是以局部变量为准

#### 作用域类型
- 全局作用域
  - 有变量提升和函数提升
- 函数作用域
  1. 使用var关键字声明的变量,会在函数中所有代码执行之前被提前声明
  2. 没有var声明的变量都是全局变量,且并不会被提前声明
  3. 定义形参就相当于在函数作用域中声明了变量
  4. 作用域是分层的,内层作用域可以访问外层作用域,反之不行
- 块级作用域
  1. 在大括号中使用let和const声明的变量存在于块级作用域中
  2. 在大括号之外不能访问这些变量
  3. **let var const 区别**

#### 作用域链
在嵌套函数中,变量会从内到外逐层寻找它的定义
就近原则

#### 变量提升
在声明之前访问var定义的变量（undefined）
但是在声明之前访问let和const的变量会得到一个引用错误

#### 函数提升
使用**函数声明**的形式创建的函数function foo(){},会被声明提前
使用**函数表达式**创建的函数const foo = function(){},不会被声明提前,所以不能在声明前调用

函数提升优先于变量提升
ES6中不需要关心谁优先提升的问题了

## 作用域和执行上下文的区别
JavaScript属于解释型语言
JavaScript的执行分为解释和执行两个阶段
- 解释阶段：
  词法分析
  语法分析
  *作用域规则确定*

- 执行阶段：相当于执行上下文的时间周期
  *创建执行上下文*
  执行函数代码
  垃圾回收

1. 作用域在函数定义时就已经确定了,但是执行上下文是函数执行之前创建的
2. 执行上下文在运行时确定,随时可能改变;作用域在定义时就确定,并且不会改变
3. 作用域用于隔离变量,执行上下文是js代码运行环境

## 闭包

## 内存泄漏

## this对象
#### this的绑定
- 默认绑定
- 隐式绑定
- new绑定
- 显示绑定