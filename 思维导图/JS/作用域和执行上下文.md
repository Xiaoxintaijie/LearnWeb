## 执行上下文
执行上下文就是当前JavaScript代码被解析和执行时所在的**环境**
JavaScript中运行任何的代码都是在执行上下文中运行

#### 执行上下文类型
- 全局执行上下文
  1. 默认/基础的上下文,任何不在函数内部的代码都在全局上下文中
  2. 一个程序中只会有一个全局执行上下文
- 函数执行上下文
  1. 每当一个函数被调用时,都会为该函数创建一个新的执行上下文
  2. 函数上下文可以有任意多个
- eval函数执行上下文
  不常用,不做讨论

#### 生命周期
##### 1.创建阶段
- this指向绑定
  1. 全局执行上下文中,this指向全局对象/window
  2. 函数执行上下文中,this取决于函数被调用的形式
  详情见标题

- 创建**词法环境**
  词法环境由以下两部分组成
  - 全局环境(没有外部环境的词法环境)
  - 函数环境(外部环境的引用)
  存储函数声明和变量let和const绑定

- 创建**变量环境**
  用于存储变量var绑定

##### 2.执行阶段
- 执行栈
  1. 用来存储代码运行时创建的所有执行上下文
  2. 先进后出的结构
  3. **事件循环**

##### 3.回收阶段
- **垃圾回收机制**

## 作用域
#### 变量
- 全局变量
  1. 全局作用域下声明的变量
  2. 在全局作用域的任何一地方，都可以访问这个变量
  3. 只有浏览器关闭时才会被销毁,比较占内存
- 局部变量
  1. 定义在函数作用域的变量
  2. 仅限函数内部访问这个变量
  3. 当其所在的代码块运行结束后,就会被销毁,比较节约内存

- 变量如果未经声明就赋值,视为全局变量
- 当局部变量和全局变量重名,则在函数内部,变量是以局部变量为准

#### 作用域类型
- 全局作用域
  - 有变量提升和函数提升
- 函数作用域
  1. 使用var关键字声明的变量,会在函数中所有代码执行之前被提前声明
  2. 没有var声明的变量都是全局变量,且并不会被提前声明
  3. 定义形参就相当于在函数作用域中声明了变量
  4. 作用域是分层的,内层作用域可以访问外层作用域,反之不行
- 块级作用域
  1. 在大括号中使用let和const声明的变量存在于块级作用域中
  2. 在大括号之外不能访问这些变量
  3. **let var const 区别**

#### 作用域链
- 子对象一级级寻找父对象的变量
- 在嵌套函数中,变量会从内到外逐层寻找它的定义
- 就近原则

#### 变量提升
在声明之前访问var定义的变量（undefined）
但是在声明之前访问let和const的变量会得到一个引用错误

#### 函数提升
使用**函数声明**的形式创建的函数function foo(){},会被声明提前
使用**函数表达式**创建的函数const foo = function(){},不会被声明提前,所以不能在声明前调用

函数提升优先于变量提升
ES6中不需要关心谁优先提升的问题了

## 作用域和执行上下文的区别
JavaScript属于解释型语言
JavaScript的执行分为解释和执行两个阶段
- 解释阶段：
  词法分析
  语法分析
  *作用域规则确定*

- 执行阶段：相当于执行上下文的时间周期
  *创建执行上下文*
  执行函数代码
  垃圾回收

1. 作用域在函数定义时就已经确定了,但是执行上下文是函数执行之前创建的
2. 执行上下文在运行时确定,随时可能改变;作用域在定义时就确定,并且不会改变
3. 作用域用于隔离变量,执行上下文是js代码运行环境

## 闭包
能够读取其他函数内部变量的函数

#### 表现形式
1. 将一个函数作为另一个函数的返回值
2. 将一个函数作为另一个函数的实参

#### 作用
1. 读取函数内部的变量
2. 让变量的值始终存在内存中

#### 缺点
1. 变量会驻留在内存中,造成内存损耗问题
   解决：把闭包的函数设置为null
2. 内存泄漏

#### 应用场景
1. 高阶函数
2. 封装JS模块

## 内存溢出
- 一种程序运行出现的**错误**
- 当程序运行需要的内存超过了剩余的内存时,就出抛出内存溢出的错误

## 内存泄漏
- 本来想回收，但实际没回收
- 指占用的内存没有及时释放出去
- 内存泄露次数多了 --> 内存溢出

#### 内存泄漏常见情况
- 闭包(预期情况，一般不会造成内存泄漏,除非滥用)
- 意外的全局变量(未声明)
- 被遗忘的计时器或回调函数
- 脱离DOM的引用

## 垃圾回收机制
JS中是自动的

垃圾回收: 当变量不在参与运行时,就需要系统收回被占用的内存空间

回收机制: 对内存中的值进行处理
- 找出不再使用的变量
- 释放其占用内存
- 固定的时间间隔运行

#### 垃圾回收的方式
- 标记清除(常用)
- 引用计数
  这种方式常常会引起内存泄漏，低版本的IE使用这种方式

#### 减少垃圾回收
1. 数组赋值为[]
2. 对于不再使用的对象,将其设置为null
3. 对函数进行优化

## this对象
#### this指向与函数的关系
- 普通函数
  window
- 对象的方法
  obj.函数名 调用函数的对象
- 构造函数
  new 函数名 创建的实例对象
- 绑定事件函数
  函数的调用者 绑定事件的对象
- 定时器函数
  window
- 立即执行函数
  window

#### this的绑定
- 默认绑定
  严格模式下,this会绑定到undefined
  只有函数运行在非严格模式下,默认绑定才能绑定到全局对象
- 隐式绑定
  方法调用模式
- new绑定
  构造器调用模式
- 显示绑定
  apply 、 call 和 bind 调用模式

#### apply call bind 区别
- apply
  1. apply(this的指向,[函数接受的参数])
  2. 当第一个参数为null、undefined的时候,默认指向window(在浏览器中)

- call
  1. call(this的指向,函数接受的参数)
  2. 当第一个参数为null、undefined的时候,默认指向window(在浏览器中)

- bind 
  1. 改变this指向后不会立即执行,而是返回一个永久改变this指向的函数
  

1. apply和call是一次性传入参数,而bind可以分为多次传入
2. bind是返回绑定this之后的函数,apply、call 则是立即执行