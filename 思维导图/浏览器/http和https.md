#### 1. tcp/ip模型：

 应用层 -> 靠近用户 http所在层
 传输层 -> 关于tcp,udp
 网际层
 网络接口层

####  2. http(超文本传输**协议**)

#####  2.1 特点：

- 端口号为80
- 非持久连接 
  > http1.0的特点，后来http1.1版本升级为持久连接
- 无状态的 
  > 但是web需要，所以后续需要使用cookie、Storage

##### 2.2 优点

##### 2.3 缺点 

- 窃听风险

- 篡改风险

- 冒充风险

  > 使用 https会改良这些缺点

##### 2.4 作用

用于请求服务器资源 

##### 2.5 组成

请求报文和响应报文

客户端向服务端发出请求，服务端收到响应客户端的请求

###### 2.5.1 请求报文: 请求行 + 请求头 + 空格 + 请求体

- 请求行: 请求方法 + url + 协议版本

  > 1,请求方法: get/post/put/delete/head/options/trace , 注意区分 get/post,有些方法是 http1.1版本新增
  >
  > 2,url 的结构：协议 + 域名 + 端口 + 路径 + 查询字符表 + 锚点链接
  >
  > **3,http1.0 1.1 2.0 3.0 版本区别**

- 请求头:定义了一个超文本传输协议事务中的操作参数

  > | 属性名          | 属性值                       | 例值             |
  > | :-------------- | :--------------------------- | ---------------- |
  > | Host            | 服务器域名(1.1新增)          | en.wikipedia.org |
  > | connection      | 客户端要求服务端使用连接类型 | keep-alive       |
  > | Accept          | 客户端能接受的回应数据格式   | \*/*             |
  > | Accept-Encoding | 客户端能接受的压缩方法       | gzip,deflate     |

- 请求体: post方法的参数放在请求体中, get放在url链接后面. 请求体可以为空。

###### 2.5.2 响应报文: 响应行 + 响应头 + 空格 + 响应体

- 相应行: 协议版本 + 状态码 + 状态码描述

  > 区分状态码：
  >
  > 1XX 提示信息,目前是协议处理的中间状态 (对于 `POST`，浏览器先发送 `header`，服务器响应 100 `continue`，浏览器再发送 `data`，服务器响应 200 ok)
  >
  > 2XX 成功
  >
  > 3XX 重定向
  >
  > 4XX 客户端错误
  >
  > 5XX 服务端错误

- 响应头

  > | 属性名           | 属性值               | 例值             |
  > | ---------------- | -------------------- | ---------------- |
  > | Content-Length   | 本次回应数据长度     | 1000(单位是字节) |
  > | Content-Type     | 本次回应数据格式     | text/html        |
  > | Content-Encoding | 本次回应数据压缩形式 | gzip             |

- 响应体: 服务器返回给客户端的信息

  

###### 2.5.3 请求头和响应头后续可以配合用于: http缓存和会话状态

##### 2.6 缓存

客户端请求资源的过程(大致): 

客户端先去本地查看浏览器缓存里是否有请求资源 

​       -> 如果没有，则向服务端重新请求

​       -> 如果有，则查看缓存是否过期

​             -> 如果未过期，那么直接使用

​             -> 如果过期，那么请求服务器资源，头部带etag，服务器决策是否真的过期

​                    -> 如果未过期，返回304，客户端继续使用缓存资源

​                    -> 如果过期，服务器返回最新资源

​     

前端缓存分为http缓存和浏览器缓存

http缓存有强缓存和协商缓存,存放在本地浏览器中

缓存的优点: 方便重复使用，减少通信次数，加速页面加载，提升用户使用感

###### 2.6.1 强缓存有关响应头

- Cache-Control
- Expires

###### 2.6.2 协商缓存有关请求头

- etag
- last-modified

#### 3. https(超文本传输安全**协议**)

##### 3.1 特点
- 默认端口号为443
- 比http多了SSL/TLS**协议**，所以更安全
  
##### 3.2 优点
- 信息加密
  > 使用对称/非对称加密方式
- 校验机制/完整性校验
  > 散列函数
- 身份认证
  > CA机构、数字签名

> 对应 http 的缺点改良方法

##### 3.3 缺点
- 性能
- 价格
- 时间
  
##### 3.4 TLS/SSL的功能实现
###### 3.4.1 对称加密
含义：加密和解密使用的秘钥都是同一个，是对称的；
优点：性能好，没那么复杂；
缺点：如果密钥泄露，那么整个加密信息都很容易被破解；
  
###### 3.4.2 非对称加密
含义：存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密；
使用：公钥加/解密或私钥加/解密；
> 公钥加密，私钥解密：加密信息
> 私钥加密，公钥解密：数字签名、验证身份

优点：安全性能更高；
缺点：消耗的性能和时间更多；

> 在 https通行中，通常使用混合加密。

###### 3.4.3 散列算法
含义：理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”；
列子：常见的散列函数有MD5、SHA1、SHA256；
作用：验证信息的完整性；

##### 3.6 证书机构(CA)
含义：数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场；
作用：用于客户端确定服务端身份；
属于第三方机构，颁发证书，附带对应的公钥；
一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们。
> 颁发流程：
> 服务端发送公钥 A到 CA，CA用自己的私钥 B加密公钥 A 得到数字签名 A；
> CA把公钥 A，数字签名 A，附加一些服务器信息整合在一起，生成证书，发回给服务器；

##### 3.5 数字签名
原理：私钥加密，公钥解密(一般公钥从CA颁发的证书中获取)；
作用：能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名；

##### 3.7 TLS1.2握手
握手基础：

- 客户端发送https请求，服务端携带CA颁发的SSL证书，里面包含公钥和私钥
- tcp进行三次握手

握手过程：大致四步组成
| 客户端 | 服务端 |
|-------| -------|
|1.Client Hello 客户端向服务端打招呼，携带随机数1、TLS版本号、加密套件  | |
| | 2.Server Hello 服务端回应客户端，携带随机数2、TLS版本号、加密套件|
| | Certificate 服务端出示证书，包含公钥 |
| | Server Hello Done 服务端发送结束标志 |
| 3.客户端发送用公钥加密后的随机数3(也称预主密钥)，客户端握手结束 | |
| | 4.Encrypted handshake message，服务端握手结束|

1. 在第2步，客户端收到服务器的证书后，会从CA处获取公钥解开证书，得到服务器的公钥A；
2. 在第3步，服务端收到预主密钥后，用私钥A 解密，获得客户端生成的随机数3；
3. 到此为止，客户端和服务端都获得了随机数1、2、3，用双方协商好的加密算法生成一个新的会话密钥；
4. 在第4步，服务端向客户端发送的消息是由会话密钥加密后，接下来的加密方式改为会话密钥；
5. 会话密钥只应用在当前会话中，安全性高；
6. 整个握手过程，签名部分采用非对称加密，消耗性能较高，后面部分得到会话密钥采用对称加密，保证安全；

